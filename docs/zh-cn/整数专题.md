
# 第1章 整数

## 面试题1：整数除法

给定两个整数 `a` 和 `b` ，求它们的除法的商 `a/b` ，要求不得使用乘号 `'*'`、除号 `'/'` 以及求余符号 `'%'` 。

```java
class Solution {
    public int divide(int a, int b) {
        int MIN=Integer.MIN_VALUE, MAX=Integer.MAX_VALUE;
        if(a==MIN && b==-1)return MAX;
        int LIMIT = -1073741824; // MIN 的一半
        boolean flag = false;
        if((a>0 && b<0) || (a<0 && b>0)) flag = true;
        if(a>0) a = -a;
        if(b>0) b = -b;
        int ans = 0;
        while(a<=b){
            //这里必须是a<=b
            int k=-1, c=b;
            //这里c>LIMIT && k>LIMIT && a-c<c判定条件加不加=都可以
            while(c>LIMIT && k>LIMIT && a-c<c){
                k = k + k;
                c = c + c;
            }
            a = a - c;
            ans = ans + k;
        }
        return flag==true ? ans : -ans;
    }
}
```

几个需要注意的点：

- 因为int型中，最小的负数要比最大的负数绝对值大1，所以`if(a==MIN && b==-1)return MAX`；
- a和b转换成负数来计算，如果都是正数，会有溢出的问题；
- 需要判断`c>LIMIT && k>LIMIT`，判断是否超过了最小负数的一半。



## 面试题2：二进制加法

**方法一：冗长但易懂**

```java
class Solution {
    public String addBinary(String a, String b) {
        int i = a.length() - 1, j = b.length() - 1;
        StringBuilder ans = new StringBuilder();
        int carry = 0, sum;
        while (i >= 0 && j >= 0) {
            sum = getNum(a.charAt(i)) + getNum(b.charAt(j)) + carry;
            carry = sum >= 2 ? 1 : 0;
            sum %= 2;
            ans.append(sum);
            i--;
            j--;
        }
        while (i >= 0) {
            sum = getNum(a.charAt(i)) + carry;
            carry = sum >= 2 ? 1 : 0;
            sum = sum % 2;
            ans.append(sum);
            i--;
        }
        while (j >= 0) {
            sum = getNum(b.charAt(j)) + carry;
            carry = sum >= 2 ? 1 : 0;
            sum = sum % 2;
            ans.append(sum);
            j--;
        }
        if (carry == 1) {
            ans.append(carry);
        }
        return ans.reverse().toString();
    }

    private int getNum(char ch) {
        return ch - '0';
    }
}
```

**方法二：简洁**

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder ans = new StringBuilder();
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;
        while (i >= 0 || j >= 0) {
            int digitA = i >= 0 ? getNum(a.charAt(i--)) : 0;
            int digitB = j >= 0 ? getNum(b.charAt(j--)) : 0;
            int sum = digitA + digitB + carry;
            carry = sum >= 2 ? 1 : 0;
            sum = sum >= 2 ? sum - 2 : sum;
            ans.append(sum);
        }
        if (carry == 1) {
            ans.append(carry);
        }
        return ans.reverse().toString();
    }

    private int getNum(char ch) {
        return ch - '0';
    }
}
```



## 面试题3：前n个数字二进制形式中1的个数

**方法一：简单计算每个整数二进制形式中的1的个数**

```java
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        for (int i = 0; i < n + 1; i++) {
            int num = i;
            while (num > 0) {
                ans[i]++;
                num = (num - 1) & num;
            }
        }
        return ans;
    }
}
```

**方法二：根据`i&(i-1)`计算二进制中1的个数**

```java
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        for (int i = 1; i < n + 1; i++) {
            ans[i] = ans[i & (i - 1)] + 1;
        }
        return ans;
    }
}
```



## 面试题4：只出现1次的数字

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] bits = new int[32];
        for (int num : nums) {
            for (int i = 0; i < 32; i++) {
                //最高位到最低位
                //+的优先级高于&，所以=后面一定要加()
                bits[i] = bits[i] + ((num >> (31 - i)) & 1);
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            ans = (ans << 1) + bits[i] % 3;
        }
        return ans;
    }
}
```

举一反三：输入一个整数数组，数组中只有一个数字出现了m次，其他数字都出现n次。找出唯一出现m次的数字。



## 面试题5：单词长度的最大乘积

给定一个字符串数组 `words`，请计算当两个字符串` words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。

**方法一：哈希表记录字符串中出现的字符**

```java
class Solution {
    public int maxProduct(String[] words) {
        boolean[][] flag = new boolean[words.length][26];
        for (int i = 0; i < words.length; i++) {
            for (char ch : words[i].toCharArray()) {
                flag[i][ch - 'a'] = true;
            }
        }
        int max = 0, k;
        for (int i = 0; i < words.length; i++) {
            for (int j = i + 1; j < words.length; j++) {
                for (k = 0; k < 26; k++) {
                    if (flag[i][k] && flag[j][k] == true) {
                        break;
                    }
                }
                if (k == 26) {
                    int product = words[i].length() * words[j].length();
                    max = Math.max(product, max);
                }
            }
        }
        return max;
    }
}
```

**方法二：整数二进制数位记录字符串出现的字符**

```java
class Solution {
    public int maxProduct(String[] words) {
        int[] flag = new int[words.length];
        int max = 0;
        for (int i = 0; i < words.length; i++) {
            for (char ch : words[i].toCharArray()) {
                flag[i] = flag[i] | (1 << (ch - 'a'));
            }
        }
        for (int i = 0; i < words.length; i++) {
            for (int j = i + 1; j < words.length; j++) {
                if ((flag[i] & flag[j]) == 0) {
                    int product = words[i].length() * words[j].length();
                    max = Math.max(max, product);
                }
            }
        }
        return max;
    }
}
```


